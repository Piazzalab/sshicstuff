"""
This module contains the commands of the program.
"""

import argparse
import os
import shutil
import subprocess
from os.path import exists, dirname, join

from docopt import docopt

import sshicstuff.core.aggregate as agg
import sshicstuff.core.filter as filt
import sshicstuff.core.methods as methods
import sshicstuff.core.pipeline as pip
import sshicstuff.core.plot as plot
import sshicstuff.core.profile as prof
import sshicstuff.core.stats as stats
import sshicstuff.log as log
from sshicstuff.gui.app import app

logger = log.logger

def check_exists(*args):
    """Check if a file exists."""
    for file_path in args:
        if exists(file_path):
            return
        else:
            logger.error("File %s does not exist.", file_path)
            raise FileNotFoundError(f"File {file_path} does not exist.")


def namespace_to_args(namespace, arg_map):
    """Convert argparse.Namespace to CLI argument list using mapping."""
    args = []
    for key, val in vars(namespace).items():
        if val is None or val is False:
            continue
        flag = arg_map[key]
        if isinstance(val, bool):
            args.append(flag)
        else:
            args.extend([flag, str(val)])
    return args



class AbstractCommand:
    """Base class for the commands"""

    def __init__(self, command_args, global_args):
        """
        Initialize the commands.

        :param command_args: arguments of the command
        :param global_args: arguments of the program
        """
        self.args = docopt(self.__doc__, argv=command_args)
        self.global_args = global_args

    def execute(self):
        """Execute the commands"""
        raise NotImplementedError


class Aggregate(AbstractCommand):
    """
    Aggregate contacts around specific regions of centromeres or telomeres.

    usage:
        aggregate -c OLIGO_CAPTURE -h CHR_COORD -p PROFILE [-o OUTPUT] [-C] [-E CHRS...] [-I] [-L] [-N] [-T] [-w WINDOW]

    Arguments:
        -c OLIGO_CAPTURE, --oligo-capture OLIGO_CAPTURE     Path to the oligo capture CSV file
                                                            Must be the file with the fragments associated
                                                            Made with the 'associate' command

        -h CHR_COORD, --chr-coord CHR_COORD                 Path to the chromosome coordinates file

        -p PROFILE, --profile PROFILE                       Path to the profile .tsv file with the binning of your choice
                                                            (recommended 1kb for telomeres and 10kb for centromes)
    Options:
        -C, --cen                                           Aggregate only centromeric regions [default: False]

        -E CHRS, --exclude=CHRS                             Exclude the chromosome(s) from the analysis

        -I, --inter                                         Only keep inter-chr contacts, i.e., removing contacts between
                                                            a probe and it own chr [default: True]

        -N, --normalize                                     Normalize the contacts by the total number of contacts
                                                            [default: False]

        -o OUTPUT, --output OUTPUT                          Desired output directory

        -T, --tel                                           Aggregate only telomeric regions [default: False]

        -w WINDOW, --window WINDOW                          Window size around the centromere or telomere to aggregate contacts
                                                            [default: 150000]

    """

    def execute(self):
        check_exists(
            self.args["--profile"],
            self.args["--chr-coord"],
            self.args["--oligo-capture"],
        )

        if self.args["--cen"] == self.args["--tel"]:
            logger.error("You must specify either telomeres or centromeres. Not both")
            logger.error("Exiting...")
            raise ValueError(
                "You must specify either telomeres or centromeres. Not both"
            )

        agg.aggregate(
            binned_contacts_path=self.args["--profile"],
            chr_coord_path=self.args["--chr-coord"],
            oligo_capture_with_frag_path=self.args["--oligo-capture"],
            window_size=int(self.args["--window"]),
            telomeres=self.args["--tel"],
            centromeres=self.args["--cen"],
            output_dir=self.args["--output"],
            excluded_chr_list=self.args["--exclude"],
            inter_only=self.args["--inter"],
            normalize=self.args["--normalize"]
        )


class Associate(AbstractCommand):
    """
    Simple and basic script to find and associate for each oligo/probe name
    a fragment id from the fragment list generated by hicstuff.

    usage:
        associate -f FRAGMENTS -o OLIGO_CAPTURE [-F]

    Arguments:
        -f FRAGMENTS, --fragments FRAGMENTS                     Path to the fragments file generated by hicstuff

        -o OLIGO_CAPTURE, --oligo-capture OLIGO_CAPTURE         Path to the oligo capture file

    Options:
        -F, --force                                             Force the overwriting of the oligos file even if
                                                                the columns are already present [default: True]
    """

    def execute(self):
        check_exists(self.args["--oligo-capture"], self.args["--fragments"])
        methods.associate_oligo_to_frag(
            oligo_capture_path=self.args["--oligo-capture"],
            fragments_path=self.args["--fragments"],
            force=self.args["--force"],
        )


class Compare(AbstractCommand):
    """
    Compare capture efficiency of a sample with a wild-type reference.

    usage:
        compare -s SAMPLE -r REFERENCE -n NAME [-o OUTPUT]

    Arguments:
        -s SAMPLE, --sample-stats SAMPLE            Path to the sample statistics file
                                                    (generated by the stats command)

        -r REFERENCE, --reference-stats REFERENCE   Path to the reference statistics file
                                                    (generated by the stats command)

        -n NAME, --name NAME                        Name of the wt type reference

    Options:
        -o OUTPUT, --output OUTPUT          Desired output directory

    """

    def execute(self):
        check_exists(self.args["--sample-stats"], self.args["--reference-stats"])
        methods.compare_with_wt(
            stats1_path=self.args["--sample-stats"],
            stats2_path=self.args["--reference-stats"],
            ref_name=self.args["--name"],
            output_dir=self.args["--output"],
        )


class Coverage(AbstractCommand):
    """
    Calculate the coverage per fragment and save the result to a bedgraph.

    usage:
        coverage -f FRAGMENTS -m SPARSE_MAT [-o OUTPUT] [-F] [-N] [-b BIN_SIZE] [-c CHR_COORD]

    Arguments:
        -f FRAGMENTS, --fragments FRAGMENTS                 Path to the digested fragments list file (hicstuff output)

        -m SPARSE_MAT, --sparse-mat SPARSE_MAT              Path to the sparse contacts input file (graal matrix from hicstuff)

    Options:

        -b BIN_SIZE, --bin-size BIN_SIZE                    Size of the bins to calculate the coverage (in bp) [default: 0]

        -c chr_coord, --chr-coord CHR_COORD                 Path to the chromosome coordinates file. Needed for the binning. [default: None]

        -o OUTPUT, --output OUTPUT                          Desired output directory file path. [default: None]

        -F, --force                                         Force the overwriting of the output file if it exists [default: False]

        -N, --normalize                                     Normalize the coverage by the total number of contacts [default: False]
    """

    def execute(self):
        check_exists(self.args["--fragments"], self.args["--sparse-mat"])
        check_exists(self.args["--chr-coord"])
        methods.coverage(
            sparse_mat_path=self.args["--sparse-mat"],
            fragments_list_path=self.args["--fragments"],
            output_dir=self.args["--output"],
            normalize=self.args["--normalize"],
            force=self.args["--force"],
            bin_size=int(self.args["--bin-size"]),
            chromosomes_coord_path=self.args["--chr-coord"],
        )


class Design(AbstractCommand):
    """
    Run oligo4sshic (Rust binary) and post-process genome fasta edition
    with the designed oligonucleotides.

    usage:
        design [<oligo4sshic args>...] [<genomaker args>...]
    """

    def __init__(self, command_args, global_args):
        if "--help" in command_args or "-h" in command_args:
            self._print_help()
            raise SystemExit(0)

        if "--version" in command_args or "-V" in command_args:
            pass

        self.global_args = global_args
        self.raw_args = command_args

        # Define which args belong to genome edition part (genomaker)
        self.genome_flags = {
            "--fragment-size",
            "--fasta-line-length",
            "--additional-fasta",
            "--n-5-prime-deletion",
            "--n-3-prime-deletion"
        }

        split_idx = self._find_split_index(command_args)
        oligo_args = command_args[:split_idx]
        genome_args = command_args[split_idx:]

        self.oligo_args = self._parse_oligo_args(oligo_args)
        self.genome_args = self._parse_genome_args(genome_args)

        # Mapping from argparse argument names to oligo4sshic CLI flags
        self.oligo4sshic_flagmap = {
            "fasta": "--fasta",
            "forward_intervals": "--forward-intervals",
            "reverse_intervals": "--reverse-intervals",
            "output_snp": "--output-snp",
            "output_raw": "--output-raw",
            "site": "--site",
            "secondary_sites": "--secondary-sites",
            "size": "--size",
            "site_start": "--site-start",
            "no_snp_zone": "--no-snp-zone",
            "complementary_size": "--complementary-size",
            "snp_number": "--snp-number",
            "tries": "--tries",
            "verbose": "--verbose",
        }

    def _print_help(self):
            print("""
    Usage:
        sshicstuff design [oligo4sshic args] [genomaker args]
        
    This command is composed of two main parts :
    
    - I - 
        Oligo4sshic: design oligonucleotides for single-strand Hi-C experiments
        oligo4sshic is a Rust based program. 
    
    - II - 
        Edition of the genome reference with the designed oligonucleotides
        Generation of the artificial chromosomes with the modified sequences.
        Format Annealing oligo table into Capture oligo table.

    Here are all the required and optional arguments for both parts. PLease provide them all at once.
    They can't be run separately.
    
    Oligo4sshic arguments:
          -f, --fasta <FASTA>
                  fasta file of the genome
              --forward-intervals <FORWARD_INTERVALS>
                  comma separated list of chromosomic interval to work on, on the forward strand (e.g. chr_a:1-100,chr_b:200-300) [default: all]
              --reverse-intervals <REVERSE_INTERVALS>
                  comma separated list of chromosomic interval to work on, on the reverse strand (e.g. chr_a:1-100,chr_b:200-300) [default: ]
              --output-snp <OUTPUT_SNP>
                  output file with the list of oligos sequence in fasta format with snp
              --output-raw <OUTPUT_RAW>
                  output file with the list of oligos sequence in fasta format without snp
              --site <SITE>
                  sequence of the site to look for for [default: GATC]
              --secondary-sites <SECONDARY_SITES>
                  comma separated list of site sequences that will be disabled by SNPs [default: CAATTG,AATATT,GANTC]
              --size <SIZE>
                  site of the oligonucleotides [default: 75]
              --site-start <SITE_START>
                  site start position withing the oligonucleotide sequences [default: 65]
              --no-snp-zone <NO_SNP_ZONE>
                  number of nucleotides that will not be transformed in SNPs after the site and before the end of the oligonucleotide sequences [default: 5]
              --complementary-size <COMPLEMENTARY_SIZE>
                  maximum number of complementary bases between two oligonucleotides [default: 7]
              --snp-number <SNP_NUMBER>
                  number of snp to add to the oligonucleotide sequence [default: 5]
              --tries <TRIES>
                  number of run to try to find the highest number of oligos [default: 20]
          -v, --verbose
                  work with the reverse complement of the fasta file

    genome edition arguments:
        -f, --fasta <FASTA>
                fasta file of the genome
                same arg as oligo4sshic (can be used for both)
        --site <STR>
                sequence of the site to look for for (default: GATC)
                same arg as oligo4sshic (can be used for both)
    
        --fragment-size <INT>               
                Size of artificial fragments (default: 150)
        --fasta-line-length <INT>           
                FASTA line wrap (default: 80)
        --additional-fasta <FASTA>          
                Additional sequences to append as artificial donor 
        --n-5-prime-deletion <INT>          
                Trimming 5' end of modified probes for capture (default: 10)
        --n-3-prime-deletion <INT>          
                Trimming 3' end of modified probes for capture (default: 10)
    """)


    def _find_split_index(self, args):
        """Return the index where genomaker args begin."""
        for i, arg in enumerate(args):
            if arg in self.genome_flags:
                return i
        return len(args)

    def _parse_oligo_args(self, args):
        parser = argparse.ArgumentParser(prog="oligo4sshic", add_help=False)
        parser.add_argument("-f", "--fasta", required=True)
        parser.add_argument("--forward-intervals")
        parser.add_argument("--reverse-intervals")
        parser.add_argument("--output-snp", required=True)
        parser.add_argument("--output-raw", required=True)
        parser.add_argument("--site", default="GATC")
        parser.add_argument("--secondary-sites", default="CAATTG,AATATT,GANTC")
        parser.add_argument("--size", type=int, default=75)
        parser.add_argument("--site-start", type=int, default=65)
        parser.add_argument("--no-snp-zone", type=int, default=5)
        parser.add_argument("--complementary-size", type=int, default=7)
        parser.add_argument("--snp-number", type=int, default=5)
        parser.add_argument("--tries", type=int, default=20)
        parser.add_argument("-v", "--verbose", action="store_true")
        parser.add_argument("-V", "--version", action="store_true")
        return parser.parse_args(args)

    def _parse_genome_args(self, args):
        parser = argparse.ArgumentParser(prog="genomaker", add_help=False)
        parser.add_argument("--fragment-size", type=int, default=150)
        parser.add_argument("--fasta-line-length", type=int, default=80)
        parser.add_argument("--additional-fasta", default=None)
        parser.add_argument("--n-5-prime-deletion", type=int, default=10)
        parser.add_argument("--n-3-prime-deletion", type=int, default=10)
        return parser.parse_args(args)

    def execute(self):
        binary = "oligo4sshic"
        output_dir = dirname(self.oligo_args.output_raw)
        os.makedirs(output_dir, exist_ok=True)
        if shutil.which(binary) is None:
            raise FileNotFoundError(f"The binary '{binary}' is not in your PATH.")

        # 1. Run oligo4sshic
        oligo_cmd = [binary] + namespace_to_args(self.oligo_args, self.oligo4sshic_flagmap)
        logger.info("Running: %s", " ".join(oligo_cmd))
        subprocess.run(oligo_cmd, check=True)

        # 2. Format annealing output
        df_annealing = methods.format_annealing_oligo_output(
            design_output_raw_path=self.oligo_args.output_raw,
            design_output_snp_path=self.oligo_args.output_snp,
        )

        # 3. Genome edition
        df_annealing2 = methods.edit_genome_ref(
            df_annealing=df_annealing,
            genome_input=self.oligo_args.fasta,
            output_dir=output_dir,
            enzyme=self.oligo_args.site,
            fragment_size=self.genome_args.fragment_size,
            fasta_line_length=self.genome_args.fasta_line_length,
            additional_fasta_path=self.genome_args.additional_fasta,
        )

        # 4. Capture generation
        capture_path = join(output_dir, "capture_oligos_positions.tsv")
        df_capture = methods.annealing_to_capture(
            df_annealing=df_annealing2,
            n_5_prime_deletion=self.genome_args.n_5_prime_deletion,
            n_3_prime_deletion=self.genome_args.n_3_prime_deletion,
        )
        df_capture.to_csv(capture_path, sep=",", index=False)
        logger.info("[Design] Capture file saved to %s", capture_path)


class Dsdnaonly(AbstractCommand):
    """
    Filter the sparse matrix by removing all the ss DNA specific contacts.
    Retain only the contacts between non-ss DNA fragments.

    usage:
        dsdnaonly -c OLIGOS_CAPTURE -m SPARSE_MATRIX [-o OUTPUT] [-n FLANKING_NUMBER] [-F]

    Arguments:
        -c OLIGOS_CAPTURE, --oligos-capture OLIGOS_CAPTURE      Path to the oligos capture file
                                                                Must be the file with the fragments associated
                                                                Made with the 'associate' command

        -m SPARSE_MATRIX, --sparse-matrix SPARSE_MATRIX         Path to the sparse matrix file

    Options:
        -o OUTPUT, --output OUTPUT                              Path to the output file

        -n FLANKING_NUMBER, --flanking-number NUMBER            Number of flanking fragments to remove
                                                                around a ssdna probe/fragment
                                                                [default: 2]

        -F, --force                                             Force the overwriting of the file if
                                                                it exists [default: False]
    """

    def execute(self):
        check_exists(self.args["--sparse-matrix"], self.args["--oligos-capture"])
        methods.sparse_with_dsdna_only(
            sample_sparse_mat=self.args["--sparse-matrix"],
            oligo_capture_with_frag_path=self.args["--oligos-capture"],
            output_path=self.args["--output"],
            n_flanking_dsdna=int(self.args["--flanking-number"]),
            force=self.args["--force"],
        )


class Filter(AbstractCommand):
    """
    Filter reads from a sparse matrix and keep only pairs of reads that contain at least one oligo/probe.

    usage:
        filter -f FRAGMENTS -c OLIGOS_CAPTURE -m SPARSE_MATRIX [-o OUTPUT] [-F]

    Arguments:
        -c OLIGOS_CAPTURE, --oligos-capture OLIGOS_CAPTURE      Path to the oligos capture file

        -f FRAGMENTS, --fragments FRAGMENTS                     Path to the digested fragments list file

        -m SPARSE_MATRIX, --sparse-matrix SPARSE_MATRIX         Path to the sparse matrix file

    Options:
        -o OUTPUT, --output OUTPUT                              Path to the output file

        -F, --force                                             Force the overwriting of the file if it exists [default: False]
    """

    def execute(self):
        check_exists(
            self.args["--fragments"],
            self.args["--oligos-capture"],
            self.args["--sparse-matrix"],
        )
        filt.filter_contacts(
            sparse_mat_path=self.args["--sparse-matrix"],
            oligo_capture_path=self.args["--oligos-capture"],
            fragments_list_path=self.args["--fragments"],
            output_path=self.args["--output"],
            force=self.args["--force"],
        )


class Merge(AbstractCommand):
    """
    Merge two or more sparse matrices into a single sparse matrix
    The merge is actually a sum of contacts for each individual fragment (reads) of each sparse.
    All sparse matrices must have the same dimensions and been mapped with the same genome reference.

    usage:
        merge [-F] [-o OUTPATH] MATRIX...

    Arguments:
        MATRIX...                                   Path to the sparse matrix files to merge
                                                    (as many as you want)

    Options:
        -o OUTPATH, --output OUTPATH                Path to the output file

        -F, --force                                 Force the overwriting of the output file if it exists [default: False]
    """

    def execute(self):
        matrices = self.args["MATRIX"]
        check_exists(*matrices)
        methods.merge_sparse_mat(
            output_path=self.args["--output"],
            force=self.args["--force"],
            matrices=matrices,
        )


class Pipeline(AbstractCommand):
    """
    Run the entire pipeline containing following steps:
    - Filter
    - HiC only
    - Coverage (full and HiC only)
    - Associate (probe <-> read)
    - Profile
    - Stats
    - Rebin
    - Aggregate (cen & telo)

    usage:
        pipeline -c OLIGO_CAPTURE -C CHR_COORD -f FRAGMENTS -m SPARSE_MATRIX
        [-a ADDITIONAL_GROUPS] [-b BINNING_SIZES...] [-E CHRS...] [-F] [-I]
        [-n FLANKING_NUMBER] [-N] [-o OUTPUT] [-r CIS_RANGE]
        [--window-size-cen WINDOW_SIZE_CEN] [--window-size-telo WINDOW_SIZE_TELO]
        [--binning-aggregate-cen BIN_CEN] [--binning-aggregate-telo BIN_TELO]
        [--copy-inputs]


    Arguments:
        -c OLIGO_CAPTURE, --oligo-capture OLIGO_CAPTURE     Path to the oligo capture file (.tsv/.csv)

        -C CHR_COORD, --chr-coord CHR_COORD                 Path to the chromosome coordinates file containing
                                                            the chromosome arms length and coordinates of centromeres

        -f FRAGMENTS, --fragments FRAGMENTS                 Path to the digested fragments list file (hicstuff output)

        -m SPARSE_MATRIX, --sparse-matrix SPARSE_MATRIX     Path to the sparse matrix file (hicstuff graal output)

    Options:
        -a ADDITIONAL_GROUPS, --additional-groups ADDITIONAL_GROUPS
                                                            Path to the additional probe groups file

        -b BINNING_SIZES, --binning-sizes BINNING_SIZES     List of binning sizes to rebin the contacts (in bp)
                                                            [default: 1000]

        -E CHRS, --exclude=CHRS                             Exclude the chromosome(s) from the analysis

        -F, --force                                         Force the overwriting of the output file if it exists
                                                            [default: False]

        -I, --inter                                         Only keep inter-chr contacts, i.e., removing contacts between
                                                            a probe and it own chr [default: True]

        -n FLANKING_NUMBER, --flanking-number NUMBER        Number of flanking fragments around the fragment
                                                            containing a DSDNA oligo to consider and remove
                                                            [default: 2]

        -N, --normalize                                     Normalize the coverage by the total number of contacts
                                                            [default: False]

        -o OUTPUT, --output OUTPUT                          Desired output directory

        -r CIS_RANGE, --cis-range CIS_RANGE                 Cis range to be considered around the probe
                                                            [default: 50000]

        --binning-aggregate-cen BIN_CEN                     Binning size of the aggregated profiles to use
                                                            for CENTROMERES [default: 10000]

        --binning-aggregate-telo BIN_TELO                   Binning size of the aggregated profiles to use
                                                            for TELOMERES [default: 1000]

        --copy-inputs                                       Copy inputs files for reproducibility [default: True]

        --window-size-cen WINDOW_SIZE_CEN                   Window size around the centromeres to aggregate contacts
                                                            [default: 150000]

        --window-size-telo WINDOW_SIZE_TELO                 Window size around the telomeres to aggregate contacts
                                                            [default: 15000]

    """

    def execute(self):
        check_exists(
            self.args["--sparse-matrix"],
            self.args["--oligo-capture"],
            self.args["--fragments"],
            self.args["--chr-coord"],
        )

        binsizes = []
        if self.args["--binning-sizes"]:
            binsizes = [int(b) for b in self.args["--binning-sizes"]]

        pip.full_pipeline(
            sample_sparse_mat=self.args["--sparse-matrix"],
            oligo_capture=self.args["--oligo-capture"],
            fragments_list=self.args["--fragments"],
            chr_coordinates=self.args["--chr-coord"],
            output_dir=self.args["--output"],
            additional_groups=self.args["--additional-groups"],
            bin_sizes=binsizes,
            cen_agg_window_size=int(self.args["--window-size-cen"]),
            cen_aggregated_binning=int(self.args["--binning-aggregate-cen"]),
            telo_agg_window_size=int(self.args["--window-size-telo"]),
            telo_agg_binning=int(self.args["--binning-aggregate-telo"]),
            excluded_chr=self.args["--exclude"],
            cis_region_size=int(self.args["--cis-range"]),
            n_flanking_dsdna=int(self.args["--flanking-number"]),
            inter_chr_only=self.args["--inter"],
            copy_inputs=self.args["--copy-inputs"],
            force=self.args["--force"],
            normalize=self.args["--normalize"],
        )


class Plot4C(AbstractCommand):
    """
    Plot a 4-C like profile.

    usage:
        plot4c -c OLIGO_CAPTURE -C CHR_COORD -p PROFILE [-e EXT] [-H HEIGHT] [-L]
        [-o OUTDIR] [-R REGION] [-r ROLLING_WINDOW] [-W WIDTH] [-y YMIN] [-Y YMAX]

    Arguments:
        -c OLIGO_CAPTURE, --oligo-capture OLIGO_CAPTURE             Path to the oligo capture CSV file (with fragment associated)

        -C CHR_COORD, --chr-coord CHR_COORD                         Path to the chromosome coordinates file

        -p PROFILE, --profile PROFILE                               Path to the profile file (mandatory)

    Options:

        -e EXT, --file-extension EXT                                File extension of the output file (png, pdf, svg, etc.)

        -H HEIGHT, --height HEIGHT                                  Height of the plot (pixels)

        -L, --log                                                   Rescale the y-axis of the plot with np.log

        -o OUTDIR, --output OUTDIR                                  Desired output DIRECTORY

        -R REGION, --region REGION                                  Region to plot (chrN-start-end), start/end in bp
                                                                    Just write chrN: for the whole chromosome

        -r ROLLING_WINDOW, --rolling-window  ROLLING_WINDOW         Apply a rolling window to the profile (convolution size)

        -W WIDTH, --width WIDTH                                     Width of the plot (pixels)

        -y YMIN, --ymin YMIN                                        Minimum value of the y-axis (unit of the Y axis)

        -Y YMAX, --ymax YMAX                                        Maximum value of the y-axis (unit of the Y axis)

    """

    def execute(self):
        check_exists(
            self.args["--profile"],
            self.args["--chr-coord"],
            self.args["--oligo-capture"],
        )

        if not self.args["--rolling-window"]:
            rolling_window = 1
        else:
            rolling_window = int(self.args["--rolling-window"])

        if not self.args["--log"]:
            log_scale = False
        else:
            log_scale = self.args["--log"]

        if not self.args["--ymin"]:
            user_y_min = None
        else:
            user_y_min = float(self.args["--ymin"])

        if not self.args["--ymax"]:
            user_y_max = None
        else:
            user_y_max = float(self.args["--ymax"])

        if not self.args["--width"]:
            width = 1200
        else:
            width = int(self.args["--width"])

        if not self.args["--height"]:
            height = 600
        else:
            height = int(self.args["--height"])

        rolling_window = (
            1
            if not self.args["--rolling-window"]
            else int(self.args["--rolling-window"])
        )
        plot.plot_profiles(
            profile_contacts_path=self.args["--profile"],
            chr_coord_path=self.args["--chr-coord"],
            oligo_capture_path=self.args["--oligo-capture"],
            output_dir=self.args["--output"],
            extension=self.args["--file-extension"],
            region=self.args["--region"],
            rolling_window=rolling_window,
            log_scale=log_scale,
            user_y_min=user_y_min,
            user_y_max=user_y_max,
            width=width,
            height=height,
        )


class Plotmatrix(AbstractCommand):
    """
    Plot a heatmap of the probes contacts matrix.

    usage:
        plotmatrix -m MATRIX [-c COLORMAP] [-L] [-o OUTPATH]
        [--probes-x PROBES] [--probes-y PROBES] [-t TITLE] [-v VMIN] [-V VMAX]

    Arguments:
        -m MATRIX, --matrix MATRIX                                  Path to the matrix file. Its a .tsv/.csv file containaing the
                                                                    contacts made by each probes with each other (mandatory)

    Options:

        -c COLORMAP, --colormap COLORMAP                            Colormap to use for the plot [default: viridis]

        -L, --log                                                   Rescale the y-axis of the plot with np.log [default: False]

        -o OUTPATH, --outpath OUTPATH                               Desired output file path (with extension) [default: None]

        --probes-x PROBES                                           Probes to keep in X axis (separated by a comma) [default: None]

        --probes-y PROBES                                           Probes to keep in Y axis (separated by a comma) [default: None]

        -t TITLE, --title TITLE                                     Title of the plot [default: None]

        -v VMIN, --vmin VMIN                                        Minimum value of the y-axis (unit of the Y axis) [default: None]

        -V VMAX, --vmax VMAX                                        Maximum value of the y-axis (unit of the Y axis) [default: None]

    """

    def execute(self):
        check_exists(self.args["--matrix"])

        # for every args thats is 'None', convert tot None
        probes_x = None if self.args["--probes-x"] == "None" else [p for p in self.args["--probes-x"].split(",")]
        probes_y = None if self.args["--probes-y"] == "None" else [p for p in self.args["--probes-y"].split(",")]
        vmin = 0. if self.args["--vmin"] == "None" else float(self.args["--vmin"])
        vmax = None if self.args["--vmax"] == "None" else float(self.args["--vmax"])
        log_scale = self.args["--log"]
        title = None if self.args["--title"] == "None" else self.args["--title"]
        output_path = None if self.args["--outpath"] == "None" else self.args["--outpath"]


        plot.plot_probes_matrix(
            probes_matrix_path=self.args["--matrix"],
            output_path=output_path,
            probes_a=probes_x,
            probes_b=probes_y,
            title=title,
            vmin=vmin,
            vmax=vmax,
            logscale=log_scale,
            cmap=self.args["--colormap"],
        )


class Profile(AbstractCommand):
    """
    Generate oligo 4-C profiles, also known as un-binned tables or 0 kn resolution tables.

    usage:
        profile -c OLIGO_CAPTURE -C CHR_COORD -f FILTERED_TAB  [-o OUTPUT] [-a ADDITIONAL] [-F] [-N] [--probes-only]

    Arguments:
        -c OLIGO_CAPTURE, --oligo-capture OLIGOS_CAPTURE       Path to the oligos capture file
                                                               Must be the file with the fragments associated
                                                               Made with the 'associate' command

        -C CHR_COORD, --chr-coord CHR_COORD                    Path to the chromosome coordinates file

        -f FILTERED_TAB, --filtered-table FILTERED_TAB         Path to the filtered table file

    Options:
        -o OUTPUT, --output OUTPUT                             Desired output file path

        -a ADDITIONAL, --additional ADDITIONAL                 Additional columns to keep in the output file [default: None]

        -F, --force                                            Force the overwriting of the output file if it exists [default: False]

        -N, --normalize                                        Normalize the coverage by the total number of contacts [default: False]

        --probes-only                                           Make a second dataframe that only contains the contacts (in frequencies) between probes (oligos)
                                                               This should have a squared-like shape [default: False]

    """

    def execute(self):
        check_exists(
            self.args["--filtered-table"],
            self.args["--oligo-capture"],
            self.args["--chr-coord"],
        )
        prof.profile_contacts(
            filtered_table_path=self.args["--filtered-table"],
            oligo_capture_with_frag_path=self.args["--oligo-capture"],
            chromosomes_coord_path=self.args["--chr-coord"],
            output_path=self.args["--output"],
            additional_groups_path=self.args["--additional"],
            normalize=self.args["--normalize"],
            force=self.args["--force"],
        )

        if self.args["--probes-only"]:
            prof.profile_probes_only(
                filtered_table_path=self.args["--filtered-table"],
                oligo_capture_with_frag_path=self.args["--oligo-capture"],
                output_path=self.args["--output"],
                force=self.args["--force"],
            )


class Rebin(AbstractCommand):
    """
    Change the binning resolution of a 4C-like profile.

    usage:
        rebin -b BINSIZE -c CHR_COORD -p PROFILE [-o OUTPUT] [-F]

    Arguments:
        -b BINSIZE, --binsize BINSIZE                     New resolution to rebin the profile (in bp) [default: 1000]

        -c CHR_COORD, --chr-coord CHR_COORD               Path to the chromosome coordinates file

        -p PROFILE, --profile PROFILE                     Path to the profile file (un-binned, 0 kb)

    Options:
        -o OUTPUT, --output OUTPUT                        Desired output file path

        -F, --force                                       Force the overwriting of the output file if it exists [default: False]
    """

    def execute(self):
        check_exists(self.args["--profile"], self.args["--chr-coord"])
        prof.rebin_profile(
            contacts_unbinned_path=self.args["--profile"],
            chromosomes_coord_path=self.args["--chr-coord"],
            bin_size=int(self.args["--binsize"]),
            output_path=self.args["--output"],
            force=self.args["--force"],
        )


class Ssdnaonly(AbstractCommand):
    """
    Filter the sparse matrix by removing all the ds DNA specific contacts.
    Retain only the contacts between ss DNA fragments.

    usage:
        ssdnaonly -c OLIGOS_CAPTURE -m SPARSE_MATRIX [-o OUTPUT] [-F]

    Arguments:
        -c OLIGOS_CAPTURE, --oligos-capture OLIGOS_CAPTURE      Path to the oligos capture file
                                                                Must be the file with the fragments associated
                                                                Made with the 'associate' command

        -m SPARSE_MATRIX, --sparse-matrix SPARSE_MATRIX         Path to the sparse matrix file

    Options:
        -o OUTPUT, --output OUTPUT                              Path to the output file

        -F, --force                                             Force the overwriting of the file if it exists [default: False]
    """

    def execute(self):
        check_exists(self.args["--sparse-matrix"], self.args["--oligos-capture"])
        methods.sparse_with_ssdna_only(
            sample_sparse_mat=self.args["--sparse-matrix"],
            oligo_capture_with_frag_path=self.args["--oligos-capture"],
            output_path=self.args["--output"],
            force=self.args["--force"],
        )


class Stats(AbstractCommand):
    """
    Generate statistics about the contacts made by each probe. Additionally, it generates
    the normalized contacts for each probe on each chromosome and on each chromosome except its own.

    It generates 3 outcomes files (.tsv):
    - contacts_statistics.tsv: contains different kinds of statistics for each probe.
    - norm_chr_freq.tsv: contains the normalized contacts for each probe on each chromosome.
    - norm_inter_chr_freq.tsv: contains the normalized contacts for each probe on each chromosome except its own.

    usage:
        stats -c OLIGO_CAPTURE -C CHR_COORD -m SPARSE_MAT -p PROFILE [-o OUTPUT] [-r CIS_RANGE] [-F]

    Arguments:
        -c OLIGO_CAPTURE, --oligo-capture OLIGO_CAPTURE     Path to the oligos capture file
                                                            Must be the file with the fragments associated
                                                            Made with the 'associate' command

        -C CHR_COORD, --chr-coord CHR_COORD                 Path to the chromosome coordinates file

        -m SPARSE_MAT, --sparse-mat SPARSE_MAT              Path to the sparse contacts input file

        -p PROFILE, --profile PROFILE                       Path to the profile file (un-binned, 0 kb)


    Options:
        -F, --force                                         Force the overwriting of the output file if the file exists [default: False]

        -o OUTPUT, --output OUTPUT                          Desired output directory

        -r CIS_RANGE, --cis-range CIS_RANGE                 Cis range to be considered around the probe [default: 50000]
    """

    def execute(self):
        check_exists(
            self.args["--profile"],
            self.args["--sparse-mat"],
            self.args["--chr-coord"],
            self.args["--oligo-capture"],
        )
        stats.get_stats(
            contacts_unbinned_path=self.args["--profile"],
            sparse_mat_path=self.args["--sparse-mat"],
            chr_coord_path=self.args["--chr-coord"],
            oligo_capture_with_frag_path=self.args["--oligo-capture"],
            output_dir=self.args["--output"],
            cis_range=int(self.args["--cis-range"]),
            force=self.args["--force"],
        )


class Subsample(AbstractCommand):
    """
    Subsample and compress FASTQ file using seqtk.

    usage:
        subsample -i INPUT [-c] [-F] [-n SIZE] [-s SEED]

    Arguments:
        -i INPUT, --input INPUT   Path to the input original FASTQ file (mandatory)

    options:
        -c, --compress            Compress the output file with gzip [default: True]

        -F, --force               Force the overwriting of the output file if it exists [default: False]

        -n SIZE, --size SIZE      Number of reads to subsample [default: 4000000]

        -s SEED, --seed SEED      Seed for the random number generator [default: 100]

    """

    def execute(self):
        check_exists(self.args["--input"])
        methods.subsample(
            input_path=self.args["--input"],
            seed=int(self.args["--seed"]),
            size=int(self.args["--size"]),
            compress=self.args["--compress"],
        )


class View(AbstractCommand):
    """
    Open a graphical user interface to visualize 4-C like profile.

    usage:
        view
    """

    def execute(self):
        logger.info("Launching the graphical interface...")
        logger.info("Cache directory: %s", methods.__CACHE_DIR__)
        app.run_server(host="0.0.0.0", port=8050, debug=True, use_reloader=False)