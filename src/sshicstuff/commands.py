"""
This module contains the commands of the program.
"""

import argparse
import shutil
import subprocess
from os.path import exists
from pathlib import Path

from docopt import docopt

import sshicstuff.core.aggregate as agg
import sshicstuff.core.filter as filt
import sshicstuff.core.methods as methods
import sshicstuff.core.pipeline as pip
import sshicstuff.core.plot as plot
import sshicstuff.core.profile as prof
import sshicstuff.core.stats as stats
import sshicstuff.log as log
from sshicstuff.gui.app import app

logger = log.logger

def check_exists(*args):
    """Check if a file exists."""
    for file_path in args:
        if exists(file_path):
            return
        else:
            logger.error("File %s does not exist.", file_path)
            raise FileNotFoundError(f"File {file_path} does not exist.")


def namespace_to_args(namespace, arg_map):
    """Convert argparse.Namespace to CLI argument list using mapping."""
    args = []
    for key, val in vars(namespace).items():
        if val is None or val is False:
            continue
        flag = arg_map[key]
        if isinstance(val, bool):
            args.append(flag)
        else:
            args.extend([flag, str(val)])
    return args



class AbstractCommand:
    """Base class for the commands"""

    def __init__(self, command_args, global_args):
        """
        Initialize the commands.

        :param command_args: arguments of the command
        :param global_args: arguments of the program
        """
        self.args = docopt(self.__doc__, argv=command_args)
        self.global_args = global_args

    def execute(self):
        """Execute the commands"""
        raise NotImplementedError


class Aggregate(AbstractCommand):
    """
    Aggregate contacts around specific regions of centromeres or telomeres.

    usage:
        aggregate -c OLIGO_CAPTURE -h CHR_COORD -p PROFILE [-o OUTPUT] [-C] [-E CHRS...] [-I] [-L] [-N] [-T] [-w WINDOW]

    Arguments:
        -c OLIGO_CAPTURE, --oligo-capture OLIGO_CAPTURE     Path to the oligo capture CSV file
                                                            Must be the file with the fragments associated
                                                            Made with the 'associate' command

        -h CHR_COORD, --chr-coord CHR_COORD                 Path to the chromosome coordinates file

        -p PROFILE, --profile PROFILE                       Path to the profile .tsv file with the binning of your choice
                                                            (recommended 1kb for telomeres and 10kb for centromes)
    Options:
        -C, --cen                                           Aggregate only centromeric regions [default: False]

        -E CHRS, --exclude=CHRS                             Exclude the chromosome(s) from the analysis

        -I, --inter                                         Only keep inter-chr contacts, i.e., removing contacts between
                                                            a probe and it own chr [default: True]

        -N, --normalize                                     Normalize the contacts by the total number of contacts
                                                            [default: False]

        -o OUTPUT, --output OUTPUT                          Desired output directory

        -T, --tel                                           Aggregate only telomeric regions [default: False]

        -w WINDOW, --window WINDOW                          Window size around the centromere or telomere to aggregate contacts
                                                            [default: 150000]

    """

    def execute(self):
        check_exists(
            self.args["--profile"],
            self.args["--chr-coord"],
            self.args["--oligo-capture"],
        )

        if self.args["--cen"] == self.args["--tel"]:
            logger.error("You must specify either telomeres or centromeres. Not both")
            logger.error("Exiting...")
            raise ValueError(
                "You must specify either telomeres or centromeres. Not both"
            )

        agg.aggregate(
            binned_contacts_path=self.args["--profile"],
            chr_coord_path=self.args["--chr-coord"],
            oligo_capture_with_frag_path=self.args["--oligo-capture"],
            window_size=int(self.args["--window"]),
            telomeres=self.args["--tel"],
            centromeres=self.args["--cen"],
            output_dir=self.args["--output"],
            excluded_chr_list=self.args["--exclude"],
            inter_only=self.args["--inter"],
            normalize=self.args["--normalize"]
        )


class Associate(AbstractCommand):
    """
    Simple and basic script to find and associate for each oligo/probe name
    a fragment id from the fragment list generated by hicstuff.

    usage:
        associate -f FRAGMENTS -o OLIGO_CAPTURE [-F]

    Arguments:
        -f FRAGMENTS, --fragments FRAGMENTS                     Path to the fragments file generated by hicstuff

        -o OLIGO_CAPTURE, --oligo-capture OLIGO_CAPTURE         Path to the oligo capture file

    Options:
        -F, --force                                             Force the overwriting of the oligos file even if
                                                                the columns are already present [default: True]
    """

    def execute(self):
        check_exists(self.args["--oligo-capture"], self.args["--fragments"])
        methods.associate_oligo_to_frag(
            oligo_capture_path=self.args["--oligo-capture"],
            fragments_path=self.args["--fragments"],
            force=self.args["--force"],
        )


class Compare(AbstractCommand):
    """
    Compare capture efficiency of a sample with a wild-type reference.

    usage:
        compare -s SAMPLE -r REFERENCE -n NAME [-o OUTPUT]

    Arguments:
        -s SAMPLE, --sample-stats SAMPLE            Path to the sample statistics file
                                                    (generated by the stats command)

        -r REFERENCE, --reference-stats REFERENCE   Path to the reference statistics file
                                                    (generated by the stats command)

        -n NAME, --name NAME                        Name of the wt type reference

    Options:
        -o OUTPUT, --output OUTPUT          Desired output directory

    """

    def execute(self):
        check_exists(self.args["--sample-stats"], self.args["--reference-stats"])
        methods.compare_with_wt(
            stats1_path=self.args["--sample-stats"],
            stats2_path=self.args["--reference-stats"],
            ref_name=self.args["--name"],
            output_dir=self.args["--output"],
        )


class Coverage(AbstractCommand):
    """
    Calculate the coverage per fragment and save the result to a bedgraph.

    usage:
        coverage -f FRAGMENTS -m SPARSE_MAT [-o OUTPUT] [-F] [-N] [-b BIN_SIZE] [-c CHR_COORD]

    Arguments:
        -f FRAGMENTS, --fragments FRAGMENTS                 Path to the digested fragments list file (hicstuff output)

        -m SPARSE_MAT, --sparse-mat SPARSE_MAT              Path to the sparse contacts input file (graal matrix from hicstuff)

    Options:

        -b BIN_SIZE, --bin-size BIN_SIZE                    Size of the bins to calculate the coverage (in bp) [default: 0]

        -c chr_coord, --chr-coord CHR_COORD                 Path to the chromosome coordinates file. Needed for the binning. [default: None]

        -o OUTPUT, --output OUTPUT                          Desired output directory file path. [default: None]

        -F, --force                                         Force the overwriting of the output file if it exists [default: False]

        -N, --normalize                                     Normalize the coverage by the total number of contacts [default: False]
    """

    def execute(self):
        check_exists(self.args["--fragments"], self.args["--sparse-mat"])
        check_exists(self.args["--chr-coord"])
        methods.coverage(
            sparse_mat_path=self.args["--sparse-mat"],
            fragments_list_path=self.args["--fragments"],
            output_dir=self.args["--output"],
            normalize=self.args["--normalize"],
            force=self.args["--force"],
            bin_size=int(self.args["--bin-size"]),
            chromosomes_coord_path=self.args["--chr-coord"],
        )


class Design:
    """
    sshicstuff design
        --genome /path/genome.fasta
        [--forward-intervals chrI:1-100,chrII:50-200]
        [--reverse-intervals chrI:1-100]
        [--site GATC]
        [--secondary-sites CAATTG,AATATT,GANTC]
        [--size 75]
        [--site-start 65]
        [--no-snp-zone 5]
        [--complementary-size 7]
        [--snp-number 5]
        [--tries 20]
        [-v]

        # OUTPUTS OF OLIGO4SSHIC RUST BINARY :
        [--o4s-output-raw  mydesign.raw.fa]
        [--o4s-output-snp  mydesign.snp.fa]

        # OUTPUTS OF THE WRAPPER (CSV + FASTA) :
        [--annealing-csv   mydesign.annealing.csv]
        [--capture-csv     mydesign.capture.csv]
        [--chr-artificial  mydesign.chr_artificial.fasta]

        # GENOME EDITION OPTIONS :
        [--fragment-size 150]
        [--fasta-line-length 80]
        [--additional-fasta extra_sequences.fasta]
        [--n-5-prime-deletion 10]
        [--n-3-prime-deletion 10]
    """

    def __init__(self, command_args, global_args=None):
        self.global_args = global_args
        self.args = self._build_parser().parse_args(command_args)

        # Resolve and prepare paths
        self.outdir = Path(self.args.outdir).resolve()
        self.outdir.mkdir(parents=True, exist_ok=True)

        # --- Sorties DU BINAIRE (FASTA) ---
        self.o4s_output_raw = methods.resolve_outpath(
            self.outdir, self.args.o4s_output_raw, f"output_o4s_raw.fa"
        )
        self.o4s_output_snp = methods.resolve_outpath(
            self.outdir, self.args.o4s_output_snp, f"outputs_o4s_snp.fa"
        )

        # --- Sorties DU WRAPPER (CSV + FASTA artificiel) ---
        if getattr(self.args, "annealing_raw_deprecated", None) or getattr(self.args, "annealing_snp_deprecated", None):
            logger.warning(
                "[Design] --annealing-raw / --annealing-snp are deprecated and were misnamed. "
                "Use --annealing-csv for the processed annealing table (CSV)."
            )

        self.annealing_csv = methods.resolve_outpath(
            self.outdir, self.args.annealing_csv, "annealing_oligo_positions.csv"
        )
        self.capture_csv = methods.resolve_outpath(
            self.outdir, self.args.capture_csv, "capture_oligo_positions.csv"
        )
        self.chr_artificial = methods.resolve_outpath(
            self.outdir, self.args.chr_artificial, "chr_artificial_ssdna.fasta"
        )

        # Oligo4sshic binary
        self.binary = "oligo4sshic"
        if shutil.which(self.binary) is None:
            raise FileNotFoundError(
                f"The binary '{self.binary}' was not found in PATH."
                f"Please install oligo4sshic in this conda env and make sure it is accessible."
            )

        # Backend flag map (fields that go to oligo4sshic)
        self.oligo4sshic_flagmap = {
            "genome": "--fasta",
            "forward_intervals": "--forward-intervals",
            "reverse_intervals": "--reverse-intervals",
            "site": "--site",
            "secondary_sites": "--secondary-sites",
            "size": "--size",
            "site_start": "--site-start",
            "no_snp_zone": "--no-snp-zone",
            "complementary_size": "--complementary-size",
            "snp_number": "--snp-number",
            "tries": "--tries",
            "verbose": "--verbose",
        }

    def _build_parser(self) -> argparse.ArgumentParser:
        p = argparse.ArgumentParser(prog="sshicstuff design", add_help=True)

        # ----- core (user-facing) -----
        p.add_argument("-f", "--genome", required=True, help="Genome FASTA")
        p.add_argument("--forward-intervals", default=None, help="e.g. chrI:1-100,chrII:50-200")
        p.add_argument("--reverse-intervals", default=None)
        p.add_argument("--site", default="GATC")
        p.add_argument("--secondary-sites", default="CAATTG,AATATT,GANTC")
        p.add_argument("--size", type=int, default=75)
        p.add_argument("--site-start", type=int, default=65)
        p.add_argument("--no-snp-zone", type=int, default=5)
        p.add_argument("--complementary-size", type=int, default=7)
        p.add_argument("--snp-number", type=int, default=5)
        p.add_argument("--tries", type=int, default=20)
        p.add_argument("-v", "--verbose", action="store_true")

        # ----- outputs (resolved under outdir unless absolute) -----
        p.add_argument("--outdir", required=True, help="Directory for all outputs")

        # BINARY O4S OUTPUTS
        p.add_argument("--o4s-output-raw", default=None, help="Raw oligos (FASTA) generated by oligo4sshic")
        p.add_argument("--o4s-output-snp", default=None, help="SNP oligos (FASTA) generated by oligo4sshic")

        # WRAPPER OUTPUTS
        p.add_argument("--annealing-csv", default=None, help="Processed annealing table (CSV)")
        p.add_argument("--capture-csv", default=None, help="Capture oligos positions (CSV)")
        p.add_argument("--chr-artificial", default=None, help="Artificial chromosomes FASTA")

        # ----- genome edition (wrapper) -----
        p.add_argument("--fragment-size", type=int, default=150)
        p.add_argument("--fasta-line-length", type=int, default=80)
        p.add_argument("--additional-fasta", default=None)
        p.add_argument("--n-5-prime-deletion", type=int, default=10)
        p.add_argument("--n-3-prime-deletion", type=int, default=10)

        return p

    # -------------- main pipeline --------------
    def execute(self):
        # 1) Run oligo4sshic
        oligo_cmd = self._build_oligo4sshic_cmd()
        logger.info("[Design] Running backend: %s", " ".join(map(str, oligo_cmd)))
        subprocess.run(oligo_cmd, check=True)

        # 2) Format annealing output (produit une table -> CSV)
        df_annealing = methods.format_annealing_oligo_output(
            design_output_raw_path=str(self.o4s_output_raw),
            design_output_snp_path=str(self.o4s_output_snp),
        )

        # 3) Genome edition (produces artificial chromosomes)
        df_annealing2 = methods.edit_genome_ref(
            df_annealing=df_annealing,
            genome_input=str(self.args.genome),
            output_dir=str(self.outdir),
            enzyme=self.args.site,
            fragment_size=self.args.fragment_size,
            fasta_line_length=self.args.fasta_line_length,
            artificial_chr_path=self.chr_artificial,
            additional_fasta_path=self.args.additional_fasta,
        )
        df_annealing2.to_csv(self.annealing_csv, sep=",", index=False)

        # 4) Capture generation (CSV)
        df_capture = methods.annealing_to_capture(
            df_annealing=df_annealing2,
            n_5_prime_deletion=self.args.n_5_prime_deletion,
            n_3_prime_deletion=self.args.n_3_prime_deletion,
        )
        df_capture.to_csv(self.capture_csv, sep=",", index=False)
        logger.info("[Design] Capture file saved to %s", self.capture_csv)

    # -------------- helpers --------------
    def _build_oligo4sshic_cmd(self) -> list[str]:
        class _O4S:  # minimal namespace
            pass

        o4s = _O4S()
        o4s.genome = self.args.genome
        o4s.forward_intervals = self.args.forward_intervals
        o4s.reverse_intervals = self.args.reverse_intervals
        o4s.site = self.args.site
        o4s.secondary_sites = self.args.secondary_sites
        o4s.size = self.args.size
        o4s.site_start = self.args.site_start
        o4s.no_snp_zone = self.args.no_snp_zone
        o4s.complementary_size = self.args.complementary_size
        o4s.snp_number = self.args.snp_number
        o4s.tries = self.args.tries
        o4s.verbose = self.args.verbose

        cmd = [self.binary]
        cmd += methods.namespace_to_args(o4s, self.oligo4sshic_flagmap)

        # Mandatory outputs for the binary o4s
        cmd += ["--output-raw", str(self.o4s_output_raw)]
        cmd += ["--output-snp", str(self.o4s_output_snp)]
        return cmd


class Dsdnaonly(AbstractCommand):
    """
    Filter the sparse matrix by removing all the ss DNA specific contacts.
    Retain only the contacts between non-ss DNA fragments.

    usage:
        dsdnaonly -c OLIGOS_CAPTURE -m SPARSE_MATRIX [-o OUTPUT] [-n FLANKING_NUMBER] [-F]

    Arguments:
        -c OLIGOS_CAPTURE, --oligos-capture OLIGOS_CAPTURE      Path to the oligos capture file
                                                                Must be the file with the fragments associated
                                                                Made with the 'associate' command

        -m SPARSE_MATRIX, --sparse-matrix SPARSE_MATRIX         Path to the sparse matrix file

    Options:
        -o OUTPUT, --output OUTPUT                              Path to the output file

        -n FLANKING_NUMBER, --flanking-number NUMBER            Number of flanking fragments to remove
                                                                around a ssdna probe/fragment
                                                                [default: 2]

        -F, --force                                             Force the overwriting of the file if
                                                                it exists [default: False]
    """

    def execute(self):
        check_exists(self.args["--sparse-matrix"], self.args["--oligos-capture"])
        methods.sparse_with_dsdna_only(
            sample_sparse_mat=self.args["--sparse-matrix"],
            oligo_capture_with_frag_path=self.args["--oligos-capture"],
            output_path=self.args["--output"],
            n_flanking_dsdna=int(self.args["--flanking-number"]),
            force=self.args["--force"],
        )


class Filter(AbstractCommand):
    """
    Filter reads from a sparse matrix and keep only pairs of reads that contain at least one oligo/probe.

    usage:
        filter -f FRAGMENTS -c OLIGOS_CAPTURE -m SPARSE_MATRIX [-o OUTPUT] [-F]

    Arguments:
        -c OLIGOS_CAPTURE, --oligos-capture OLIGOS_CAPTURE      Path to the oligos capture file

        -f FRAGMENTS, --fragments FRAGMENTS                     Path to the digested fragments list file

        -m SPARSE_MATRIX, --sparse-matrix SPARSE_MATRIX         Path to the sparse matrix file

    Options:
        -o OUTPUT, --output OUTPUT                              Path to the output file

        -F, --force                                             Force the overwriting of the file if it exists [default: False]
    """

    def execute(self):
        check_exists(
            self.args["--fragments"],
            self.args["--oligos-capture"],
            self.args["--sparse-matrix"],
        )
        filt.filter_contacts(
            sparse_mat_path=self.args["--sparse-matrix"],
            oligo_capture_path=self.args["--oligos-capture"],
            fragments_list_path=self.args["--fragments"],
            output_path=self.args["--output"],
            force=self.args["--force"],
        )


class Merge(AbstractCommand):
    """
    Merge two or more sparse matrices into a single sparse matrix
    The merge is actually a sum of contacts for each individual fragment (reads) of each sparse.
    All sparse matrices must have the same dimensions and been mapped with the same genome reference.

    usage:
        merge [-F] [-o OUTPATH] MATRIX...

    Arguments:
        MATRIX...                                   Path to the sparse matrix files to merge
                                                    (as many as you want)

    Options:
        -o OUTPATH, --output OUTPATH                Path to the output file

        -F, --force                                 Force the overwriting of the output file if it exists [default: False]
    """

    def execute(self):
        matrices = self.args["MATRIX"]
        check_exists(*matrices)
        methods.merge_sparse_mat(
            output_path=self.args["--output"],
            force=self.args["--force"],
            matrices=matrices,
        )


class Pipeline(AbstractCommand):
    """
    Run the entire pipeline containing following steps:
    - Filter
    - HiC only
    - Coverage (full and HiC only)
    - Associate (probe <-> read)
    - Profile
    - Stats
    - Rebin
    - Aggregate (cen & telo)

    usage:
        pipeline -c OLIGO_CAPTURE -C CHR_COORD -f FRAGMENTS -m SPARSE_MATRIX
        [-a ADDITIONAL_GROUPS] [-b BINNING_SIZES...] [-E CHRS...] [-F] [-I]
        [-n FLANKING_NUMBER] [-N] [-o OUTPUT] [-r CIS_RANGE]
        [--window-size-cen WINDOW_SIZE_CEN] [--window-size-telo WINDOW_SIZE_TELO]
        [--binning-aggregate-cen BIN_CEN] [--binning-aggregate-telo BIN_TELO]
        [--copy-inputs]


    Arguments:
        -c OLIGO_CAPTURE, --oligo-capture OLIGO_CAPTURE     Path to the oligo capture file (.tsv/.csv)

        -C CHR_COORD, --chr-coord CHR_COORD                 Path to the chromosome coordinates file containing
                                                            the chromosome arms length and coordinates of centromeres

        -f FRAGMENTS, --fragments FRAGMENTS                 Path to the digested fragments list file (hicstuff output)

        -m SPARSE_MATRIX, --sparse-matrix SPARSE_MATRIX     Path to the sparse matrix file (hicstuff graal output)

    Options:
        -a ADDITIONAL_GROUPS, --additional-groups ADDITIONAL_GROUPS
                                                            Path to the additional probe groups file

        -b BINNING_SIZES, --binning-sizes BINNING_SIZES     List of binning sizes to rebin the contacts (in bp)
                                                            [default: 1000]

        -E CHRS, --exclude=CHRS                             Exclude the chromosome(s) from the analysis

        -F, --force                                         Force the overwriting of the output file if it exists
                                                            [default: False]

        -I, --inter                                         Only keep inter-chr contacts, i.e., removing contacts between
                                                            a probe and it own chr [default: True]

        -n FLANKING_NUMBER, --flanking-number NUMBER        Number of flanking fragments around the fragment
                                                            containing a DSDNA oligo to consider and remove
                                                            [default: 2]

        -N, --normalize                                     Normalize the coverage by the total number of contacts
                                                            [default: False]

        -o OUTPUT, --output OUTPUT                          Desired output directory

        -r CIS_RANGE, --cis-range CIS_RANGE                 Cis range to be considered around the probe
                                                            [default: 50000]

        --binning-aggregate-cen BIN_CEN                     Binning size of the aggregated profiles to use
                                                            for CENTROMERES [default: 10000]

        --binning-aggregate-telo BIN_TELO                   Binning size of the aggregated profiles to use
                                                            for TELOMERES [default: 1000]

        --copy-inputs                                       Copy inputs files for reproducibility [default: True]

        --window-size-cen WINDOW_SIZE_CEN                   Window size around the centromeres to aggregate contacts
                                                            [default: 150000]

        --window-size-telo WINDOW_SIZE_TELO                 Window size around the telomeres to aggregate contacts
                                                            [default: 15000]

    """

    def execute(self):
        check_exists(
            self.args["--sparse-matrix"],
            self.args["--oligo-capture"],
            self.args["--fragments"],
            self.args["--chr-coord"],
        )

        binsizes = []
        if self.args["--binning-sizes"]:
            binsizes = [int(b) for b in self.args["--binning-sizes"]]

        pip.full_pipeline(
            sample_sparse_mat=self.args["--sparse-matrix"],
            oligo_capture=self.args["--oligo-capture"],
            fragments_list=self.args["--fragments"],
            chr_coordinates=self.args["--chr-coord"],
            output_dir=self.args["--output"],
            additional_groups=self.args["--additional-groups"],
            bin_sizes=binsizes,
            cen_agg_window_size=int(self.args["--window-size-cen"]),
            cen_aggregated_binning=int(self.args["--binning-aggregate-cen"]),
            telo_agg_window_size=int(self.args["--window-size-telo"]),
            telo_agg_binning=int(self.args["--binning-aggregate-telo"]),
            excluded_chr=self.args["--exclude"],
            cis_region_size=int(self.args["--cis-range"]),
            n_flanking_dsdna=int(self.args["--flanking-number"]),
            inter_chr_only=self.args["--inter"],
            copy_inputs=self.args["--copy-inputs"],
            force=self.args["--force"],
            normalize=self.args["--normalize"],
        )


class Plot4C(AbstractCommand):
    """
    Plot a 4-C like profile.

    usage:
        plot4c -c OLIGO_CAPTURE -C CHR_COORD -p PROFILE [-e EXT] [-H HEIGHT] [-L]
        [-o OUTDIR] [-R REGION] [-r ROLLING_WINDOW] [-W WIDTH] [-y YMIN] [-Y YMAX]

    Arguments:
        -c OLIGO_CAPTURE, --oligo-capture OLIGO_CAPTURE             Path to the oligo capture CSV file (with fragment associated)

        -C CHR_COORD, --chr-coord CHR_COORD                         Path to the chromosome coordinates file

        -p PROFILE, --profile PROFILE                               Path to the profile file (mandatory)

    Options:

        -e EXT, --file-extension EXT                                File extension of the output file (png, pdf, svg, etc.)

        -H HEIGHT, --height HEIGHT                                  Height of the plot (pixels)

        -L, --log                                                   Rescale the y-axis of the plot with np.log

        -o OUTDIR, --output OUTDIR                                  Desired output DIRECTORY

        -R REGION, --region REGION                                  Region to plot (chrN-start-end), start/end in bp
                                                                    Just write chrN: for the whole chromosome

        -r ROLLING_WINDOW, --rolling-window  ROLLING_WINDOW         Apply a rolling window to the profile (convolution size)

        -W WIDTH, --width WIDTH                                     Width of the plot (pixels)

        -y YMIN, --ymin YMIN                                        Minimum value of the y-axis (unit of the Y axis)

        -Y YMAX, --ymax YMAX                                        Maximum value of the y-axis (unit of the Y axis)

    """

    def execute(self):
        check_exists(
            self.args["--profile"],
            self.args["--chr-coord"],
            self.args["--oligo-capture"],
        )

        if not self.args["--rolling-window"]:
            rolling_window = 1
        else:
            rolling_window = int(self.args["--rolling-window"])

        if not self.args["--log"]:
            log_scale = False
        else:
            log_scale = self.args["--log"]

        if not self.args["--ymin"]:
            user_y_min = None
        else:
            user_y_min = float(self.args["--ymin"])

        if not self.args["--ymax"]:
            user_y_max = None
        else:
            user_y_max = float(self.args["--ymax"])

        if not self.args["--width"]:
            width = 1200
        else:
            width = int(self.args["--width"])

        if not self.args["--height"]:
            height = 600
        else:
            height = int(self.args["--height"])

        rolling_window = (
            1
            if not self.args["--rolling-window"]
            else int(self.args["--rolling-window"])
        )
        plot.plot_profiles(
            profile_contacts_path=self.args["--profile"],
            chr_coord_path=self.args["--chr-coord"],
            oligo_capture_path=self.args["--oligo-capture"],
            output_dir=self.args["--output"],
            extension=self.args["--file-extension"],
            region=self.args["--region"],
            rolling_window=rolling_window,
            log_scale=log_scale,
            user_y_min=user_y_min,
            user_y_max=user_y_max,
            width=width,
            height=height,
        )


class Plotmatrix(AbstractCommand):
    """
    Plot a heatmap of the probes contacts matrix.

    usage:
        plotmatrix -m MATRIX [-c COLORMAP] [-L] [-o OUTPATH]
        [--probes-x PROBES] [--probes-y PROBES] [-t TITLE] [-v VMIN] [-V VMAX]

    Arguments:
        -m MATRIX, --matrix MATRIX                                  Path to the matrix file. Its a .tsv/.csv file containaing the
                                                                    contacts made by each probes with each other (mandatory)

    Options:

        -c COLORMAP, --colormap COLORMAP                            Colormap to use for the plot [default: viridis]

        -L, --log                                                   Rescale the y-axis of the plot with np.log [default: False]

        -o OUTPATH, --outpath OUTPATH                               Desired output file path (with extension) [default: None]

        --probes-x PROBES                                           Probes to keep in X axis (separated by a comma) [default: None]

        --probes-y PROBES                                           Probes to keep in Y axis (separated by a comma) [default: None]

        -t TITLE, --title TITLE                                     Title of the plot [default: None]

        -v VMIN, --vmin VMIN                                        Minimum value of the y-axis (unit of the Y axis) [default: None]

        -V VMAX, --vmax VMAX                                        Maximum value of the y-axis (unit of the Y axis) [default: None]

    """

    def execute(self):
        check_exists(self.args["--matrix"])

        # for every args thats is 'None', convert tot None
        probes_x = None if self.args["--probes-x"] == "None" else [p for p in self.args["--probes-x"].split(",")]
        probes_y = None if self.args["--probes-y"] == "None" else [p for p in self.args["--probes-y"].split(",")]
        vmin = 0. if self.args["--vmin"] == "None" else float(self.args["--vmin"])
        vmax = None if self.args["--vmax"] == "None" else float(self.args["--vmax"])
        log_scale = self.args["--log"]
        title = None if self.args["--title"] == "None" else self.args["--title"]
        output_path = None if self.args["--outpath"] == "None" else self.args["--outpath"]


        plot.plot_probes_matrix(
            probes_matrix_path=self.args["--matrix"],
            output_path=output_path,
            probes_a=probes_x,
            probes_b=probes_y,
            title=title,
            vmin=vmin,
            vmax=vmax,
            logscale=log_scale,
            cmap=self.args["--colormap"],
        )


class Profile(AbstractCommand):
    """
    Generate oligo 4-C profiles, also known as un-binned tables or 0 kn resolution tables.

    usage:
        profile -c OLIGO_CAPTURE -C CHR_COORD -f FILTERED_TAB  [-o OUTPUT] [-a ADDITIONAL] [-F] [-N] [--probes-only]

    Arguments:
        -c OLIGO_CAPTURE, --oligo-capture OLIGOS_CAPTURE       Path to the oligos capture file
                                                               Must be the file with the fragments associated
                                                               Made with the 'associate' command

        -C CHR_COORD, --chr-coord CHR_COORD                    Path to the chromosome coordinates file

        -f FILTERED_TAB, --filtered-table FILTERED_TAB         Path to the filtered table file

    Options:
        -o OUTPUT, --output OUTPUT                             Desired output file path

        -a ADDITIONAL, --additional ADDITIONAL                 Additional columns to keep in the output file [default: None]

        -F, --force                                            Force the overwriting of the output file if it exists [default: False]

        -N, --normalize                                        Normalize the coverage by the total number of contacts [default: False]

        --probes-only                                           Make a second dataframe that only contains the contacts (in frequencies) between probes (oligos)
                                                               This should have a squared-like shape [default: False]

    """

    def execute(self):
        check_exists(
            self.args["--filtered-table"],
            self.args["--oligo-capture"],
            self.args["--chr-coord"],
        )
        prof.profile_contacts(
            filtered_table_path=self.args["--filtered-table"],
            oligo_capture_with_frag_path=self.args["--oligo-capture"],
            chromosomes_coord_path=self.args["--chr-coord"],
            output_path=self.args["--output"],
            additional_groups_path=self.args["--additional"],
            normalize=self.args["--normalize"],
            force=self.args["--force"],
        )

        if self.args["--probes-only"]:
            prof.profile_probes_only(
                filtered_table_path=self.args["--filtered-table"],
                oligo_capture_with_frag_path=self.args["--oligo-capture"],
                output_path=self.args["--output"],
                force=self.args["--force"],
            )


class Rebin(AbstractCommand):
    """
    Change the binning resolution of a 4C-like profile.

    usage:
        rebin -b BINSIZE -c CHR_COORD -p PROFILE [-o OUTPUT] [-F]

    Arguments:
        -b BINSIZE, --binsize BINSIZE                     New resolution to rebin the profile (in bp) [default: 1000]

        -c CHR_COORD, --chr-coord CHR_COORD               Path to the chromosome coordinates file

        -p PROFILE, --profile PROFILE                     Path to the profile file (un-binned, 0 kb)

    Options:
        -o OUTPUT, --output OUTPUT                        Desired output file path

        -F, --force                                       Force the overwriting of the output file if it exists [default: False]
    """

    def execute(self):
        check_exists(self.args["--profile"], self.args["--chr-coord"])
        prof.rebin_profile(
            contacts_unbinned_path=self.args["--profile"],
            chromosomes_coord_path=self.args["--chr-coord"],
            bin_size=int(self.args["--binsize"]),
            output_path=self.args["--output"],
            force=self.args["--force"],
        )


class Ssdnaonly(AbstractCommand):
    """
    Filter the sparse matrix by removing all the ds DNA specific contacts.
    Retain only the contacts between ss DNA fragments.

    usage:
        ssdnaonly -c OLIGOS_CAPTURE -m SPARSE_MATRIX [-o OUTPUT] [-F]

    Arguments:
        -c OLIGOS_CAPTURE, --oligos-capture OLIGOS_CAPTURE      Path to the oligos capture file
                                                                Must be the file with the fragments associated
                                                                Made with the 'associate' command

        -m SPARSE_MATRIX, --sparse-matrix SPARSE_MATRIX         Path to the sparse matrix file

    Options:
        -o OUTPUT, --output OUTPUT                              Path to the output file

        -F, --force                                             Force the overwriting of the file if it exists [default: False]
    """

    def execute(self):
        check_exists(self.args["--sparse-matrix"], self.args["--oligos-capture"])
        methods.sparse_with_ssdna_only(
            sample_sparse_mat=self.args["--sparse-matrix"],
            oligo_capture_with_frag_path=self.args["--oligos-capture"],
            output_path=self.args["--output"],
            force=self.args["--force"],
        )


class Stats(AbstractCommand):
    """
    Generate statistics about the contacts made by each probe. Additionally, it generates
    the normalized contacts for each probe on each chromosome and on each chromosome except its own.

    It generates 3 outcomes files (.tsv):
    - contacts_statistics.tsv: contains different kinds of statistics for each probe.
    - norm_chr_freq.tsv: contains the normalized contacts for each probe on each chromosome.
    - norm_inter_chr_freq.tsv: contains the normalized contacts for each probe on each chromosome except its own.

    usage:
        stats -c OLIGO_CAPTURE -C CHR_COORD -m SPARSE_MAT -p PROFILE [-o OUTPUT] [-r CIS_RANGE] [-F]

    Arguments:
        -c OLIGO_CAPTURE, --oligo-capture OLIGO_CAPTURE     Path to the oligos capture file
                                                            Must be the file with the fragments associated
                                                            Made with the 'associate' command

        -C CHR_COORD, --chr-coord CHR_COORD                 Path to the chromosome coordinates file

        -m SPARSE_MAT, --sparse-mat SPARSE_MAT              Path to the sparse contacts input file

        -p PROFILE, --profile PROFILE                       Path to the profile file (un-binned, 0 kb)


    Options:
        -F, --force                                         Force the overwriting of the output file if the file exists [default: False]

        -o OUTPUT, --output OUTPUT                          Desired output directory

        -r CIS_RANGE, --cis-range CIS_RANGE                 Cis range to be considered around the probe [default: 50000]
    """

    def execute(self):
        check_exists(
            self.args["--profile"],
            self.args["--sparse-mat"],
            self.args["--chr-coord"],
            self.args["--oligo-capture"],
        )
        stats.get_stats(
            contacts_unbinned_path=self.args["--profile"],
            sparse_mat_path=self.args["--sparse-mat"],
            chr_coord_path=self.args["--chr-coord"],
            oligo_capture_with_frag_path=self.args["--oligo-capture"],
            output_dir=self.args["--output"],
            cis_range=int(self.args["--cis-range"]),
            force=self.args["--force"],
        )


class Subsample(AbstractCommand):
    """
    Subsample and compress FASTQ file using seqtk.

    usage:
        subsample -i INPUT [-c] [-F] [-n SIZE] [-s SEED]

    Arguments:
        -i INPUT, --input INPUT   Path to the input original FASTQ file (mandatory)

    options:
        -c, --compress            Compress the output file with gzip [default: True]

        -F, --force               Force the overwriting of the output file if it exists [default: False]

        -n SIZE, --size SIZE      Number of reads to subsample [default: 4000000]

        -s SEED, --seed SEED      Seed for the random number generator [default: 100]

    """

    def execute(self):
        check_exists(self.args["--input"])
        methods.subsample(
            input_path=self.args["--input"],
            seed=int(self.args["--seed"]),
            size=int(self.args["--size"]),
            compress=self.args["--compress"],
        )


class View(AbstractCommand):
    """
    Open a graphical user interface to visualize 4-C like profile.

    usage:
        view
    """

    def execute(self):
        logger.info("Launching the graphical interface...")
        logger.info("Cache directory: %s", methods.__CACHE_DIR__)
        app.run_server(host="0.0.0.0", port=3838, debug=True, use_reloader=False)