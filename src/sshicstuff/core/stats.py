"""
This module contains the functions to generate statistics for contacts made by each probe.
"""

import os
import pandas as pd
import numpy as np

import sshicstuff.core.methods as methods
import sshicstuff.log as log

logger = log.logger


def get_stats(
    contacts_unbinned_path: str,
    sparse_mat_path: str,
    chr_coord_path: str,
    oligo_capture_with_frag_path: str,
    output_dir: str = None,
    cis_range: int = 50000,
    force: bool = False,
):
    """
    Generate statistics for contacts made by each probe.

    It generates 3 outputs file (.tsv):
    - contacts_statistics.tsv: contains different kinds of statistics for each probe.
    - norm_chr_freq.tsv: contains the normalized contacts for each probe on each chromosome.
    - norm_inter_chr_freq.tsv: contains the normalized contacts for each probe on each chromosome except its own.

    Parameters
    ----------

    contacts_unbinned_path : str
        Path to the unbinned_contacts.tsv file (generated by fragments).
    sparse_mat_path : str
        Path to the sparse_contacts_input.txt file (generated by hicstuff).
    chr_coord_path : str
        Path to the input chr_centros_coordinates.tsv file.
    oligo_capture_with_frag_path : str
        Path to the oligo input CSV file.
        Must contain fragments associated Made with the 'associate' command
    cis_range: int, default=50000
        Cis range to be considered around the probe.
    output_dir : str
        Path to the output directory.
    force : bool
        Force the overwriting of the output file if the file exists.

    Returns
    -------

    None
    """

    logger.info("[Stats] : Generating statistics for contacts made by each probe.")

    methods.check_if_exists(contacts_unbinned_path)
    methods.check_if_exists(sparse_mat_path)
    methods.check_if_exists(chr_coord_path)
    methods.check_if_exists(oligo_capture_with_frag_path)

    if output_dir is None:
        output_dir = os.path.dirname(contacts_unbinned_path)

    sample_name = os.path.basename(sparse_mat_path).split(".")[0]
    out_stats_path = os.path.join(output_dir, f"{sample_name}_statistics.tsv")
    out_chr_freq_path = os.path.join(output_dir, f"{sample_name}_norm_chr_freq.tsv")
    out_inter_chr_freq_path = os.path.join(
        output_dir, f"{sample_name}_norm_inter_chr_freq.tsv"
    )

    if os.path.exists(out_stats_path) and not force:
        logger.warning("[Stats] : Output file already exists: %s", out_stats_path)
        logger.warning(
            "[Stats] : Use the --force / -F flag to overwrite the existing file."
        )
        return

    oligo_delim = "," if oligo_capture_with_frag_path.endswith(".csv") else "\t"
    df_oligo: pd.DataFrame = pd.read_csv(oligo_capture_with_frag_path, sep=oligo_delim)

    coords_delim = "\t" if chr_coord_path.endswith(".tsv") else ","
    df_coords: pd.DataFrame = pd.read_csv(
        chr_coord_path, sep=coords_delim, index_col=None
    )

    chr_size_dict = {k: v for k, v in zip(df_coords["chr"], df_coords["length"])}
    chr_list = list(chr_size_dict.keys())

    df: pd.DataFrame = pd.read_csv(contacts_unbinned_path, sep="\t")
    df = df.astype(dtype={"chr": str, "start": int, "sizes": int})

    df_without_artificial = df[~df["chr"].isin(["chr_artificial_ssDNA", "chr_artificial_dsDNA"])]
    df_only_artificial = df[df["chr"].isin(["chr_artificial_ssDNA", "chr_artificial_dsDNA"])]

    df_sparse_contacts: pd.DataFrame = pd.read_csv(
        sparse_mat_path, header=0, sep="\t", names=["frag_a", "frag_b", "contacts"]
    )
    #   from sparse_matrix (hicstuff results): get total contacts from which probes enrichment is calculated
    total_sparse_contacts = sum(df_sparse_contacts["contacts"])

    chr_contacts_nrm = {k: [] for k in chr_size_dict}
    chr_inter_only_contacts_nrm = {k: [] for k in chr_size_dict}

    df_stats: pd.DataFrame = pd.DataFrame(
        columns=[
            "probe",
            "chr",
            "fragment",
            "type",
            "contacts",
            "coverage_over_hic_contacts",
            "cis",
            "trans",
            "cis_with_artificial",
            "trans_with_artificial",
            "intra_chr",
            "inter_chr",
        ]
    )

    probes = df_oligo["name"].to_list()
    fragments = df_oligo["fragment"].astype(str).to_list()
    for index, (probe, frag) in enumerate(zip(probes, fragments)):
        df_stats.loc[index, "probe"] = probe
        df_stats.loc[index, "fragment"] = frag
        df_stats.loc[index, "type"] = df_oligo.loc[index, "type"]

        #  get the probe's original coordinates
        self_chr = df_oligo.loc[index, "chr"]
        self_chr_ori = df_oligo.loc[index, "chr_ori"]
        self_start_ori = df_oligo.loc[index, "start_ori"]
        self_stop_ori = df_oligo.loc[index, "stop_ori"]

        df_stats.loc[index, "chr"] = self_chr_ori

        # Number of contacts made by the probe
        sub_df = df[["chr", "start", "sizes", frag]]
        probe_contacts = df[frag].sum()

        if probe_contacts > 0:
            df_stats.loc[index, "contacts"] = probe_contacts
            df_stats.loc[index, "coverage_over_hic_contacts"] = (
                probe_contacts / total_sparse_contacts
            )
            probes_contacts_inter = sub_df.query(
                "chr != @self_chr_ori & chr != @self_chr"
            )[frag].sum()
            inter_chr_freq = probes_contacts_inter / probe_contacts
            intra_chr_freq = 1 - inter_chr_freq

            # A : computing cis contacts for the probes without
            # considering the artificial chromosomes

            sub_df_without_artificial = df_without_artificial[["chr", "start", "sizes", frag]]
            sub_df_without_artificial.insert(
                3,
                "end",
                sub_df_without_artificial["start"] + sub_df_without_artificial["sizes"],
            )
            cis_start = self_start_ori - cis_range
            cis_stop = self_stop_ori + cis_range
            probe_contacts_without_artificial = sub_df_without_artificial[frag].sum()
            cis_without_artificial_contacts = sub_df_without_artificial.query(
                "chr == @self_chr_ori & start >= @cis_start & end <= @cis_stop"
            )[frag].sum()
            
            cis_without_artificial_freq = (
                cis_without_artificial_contacts / probe_contacts_without_artificial
            )

            # B : computing additional cis portion of contacts for the probes
            # with only the artificial chromosomes

            cis_only_artificial_contacts = df_only_artificial[frag].sum()

            # C : computing the total cis portion of contacts for the probes
            # # with the artificial chromosomes and without (rest of the genome)
            cis_contacts_with_artificial = (
                cis_without_artificial_contacts + cis_only_artificial_contacts
            )
            cis_freq_with_artificial = cis_contacts_with_artificial / probe_contacts

            cis_freq = cis_without_artificial_freq
            trans_freq = 1 - cis_freq
            trans_freq_with_artificial = 1 - cis_freq_with_artificial

        else:
            cis_freq = 0
            trans_freq = 0
            cis_freq_with_artificial = 0
            trans_freq_with_artificial = 0
            inter_chr_freq = 0
            intra_chr_freq = 0

        df_stats.loc[index, "cis"] = cis_freq
        df_stats.loc[index, "trans"] = trans_freq
        df_stats.loc[index, "cis_with_artificial"] = cis_freq_with_artificial
        df_stats.loc[index, "trans_with_artificial"] = trans_freq_with_artificial
        df_stats.loc[index, "intra_chr"] = intra_chr_freq
        df_stats.loc[index, "inter_chr"] = inter_chr_freq

        for chrom in chr_list:
            #   n1: sum contacts chr_i
            #   d1: sum contacts all chr
            #   chrom_size: chr_i's size
            #   genome_size: sum of sizes for all chr except frag_chr
            #   c1: normalized contacts on chr_i for frag_j
            chrom_size = chr_size_dict[chrom]
            genome_size = sum(
                [s for c, s in chr_size_dict.items() if c != self_chr_ori]
            )
            n1 = sub_df.loc[sub_df["chr"] == chrom, frag].sum()
            if n1 == 0:
                chr_contacts_nrm[chrom].append(0)
            else:
                d1 = probe_contacts
                c1 = (n1 / d1) / (chrom_size / genome_size)
                chr_contacts_nrm[chrom].append(c1)

            #   n2: sum contacts chr_i if chr_i != probe_chr
            #   d2: sum contacts all inter chr (exclude the probe_chr)
            #   c2: normalized inter chr contacts on chr_i for frag_j
            n2 = sub_df.loc[
                (sub_df["chr"] == chrom) & (sub_df["chr"] != self_chr_ori), frag
            ].sum()

            if n2 == 0:
                chr_inter_only_contacts_nrm[chrom].append(0)
            else:
                d2 = probes_contacts_inter
                c2 = (n2 / d2) / (chrom_size / genome_size)
                chr_inter_only_contacts_nrm[chrom].append(c2)

    #  capture_efficiency_vs_dsdna: amount of contact for one oligo divided
    #  by the mean of all other 'ds' oligo in the genome
    n3 = df_stats.loc[:, "contacts"]
    d3 = np.mean(df_stats.loc[df_stats["type"] == "ds", "contacts"])
    df_stats["dsdna_norm_capture_efficiency"] = n3 / d3

    df_chr_nrm = pd.DataFrame(
        {"probe": probes, "fragment": fragments, "type": df_oligo["type"].values}
    )

    df_chr_inter_only_nrm = df_chr_nrm.copy(deep=True)

    for chr_id in chr_list:
        df_chr_nrm[chr_id] = chr_contacts_nrm[chr_id]
        df_chr_inter_only_nrm[chr_id] = chr_inter_only_contacts_nrm[chr_id]

    df_stats.to_csv(out_stats_path, sep="\t", index=False)
    df_chr_nrm.to_csv(out_chr_freq_path, sep="\t", index=False)
    df_chr_inter_only_nrm.to_csv(out_inter_chr_freq_path, sep="\t", index=False)

    logger.info("[Stats] : Statistics saved to %s", out_stats_path)
    logger.info("[Stats] : Normalized chr contacts saved to %s", out_chr_freq_path)
    logger.info(
        "[Stats] : Normalized inter-only chr contacts saved to %s",
        out_inter_chr_freq_path,
    )
    